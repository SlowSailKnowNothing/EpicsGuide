全排列问题：

```
给定一个 没有重复 数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/permutations
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```



```java

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;


public class Solution {

    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        // 使用一个动态数组保存所有可能的全排列
        List<List<Integer>> res = new ArrayList<>();
        if (len == 0) {
            return res;
        }

        boolean[] used = new boolean[len];
        Deque<Integer> path = new ArrayDeque<>(len);

        dfs(nums, len, 0, path, used, res);
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     Deque<Integer> path, boolean[] used,
                     List<List<Integer>> res) {
        if (depth == len) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < len; i++) {
            if (!used[i]) {
                path.addLast(nums[i]);
                used[i] = true;

                System.out.println("  递归之前 => " + path);
                dfs(nums, len, depth + 1, path, used, res);

                used[i] = false;
                path.removeLast();
                System.out.println("递归之后 => " + path);
            }
        }
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        Solution solution = new Solution();
        List<List<Integer>> lists = solution.permute(nums);
        System.out.println(lists);
    }
}


```

语法知识：

```java
List<List<Integer>> res=new ArrayList<>();
int length=nums.length;
if(length==0)return res;

boolean[] used=new boolean[length];
Deque<Integer> path=new ArrayDeque<>(length);

dfs(nums,length,0,path,used);
return res;

private dfs(List<List<Integer>> nums,int length,int depth,Deque<Integer> path,boolean[] used){
    if(depth==length)
    {
        res.add(new ArrayList<>(path));
        return;
    }
    for(int i=0;i<letngh;i++)
    {
        if(use[i])continue;
        path.addLast(nums[i]);
        used[i]==true;
        dfs(nums,length,depth+1,path,used);
        
        path.removeLast();
        usde[i]==false;
    }
}
```

整个思考过程：

​	实际上可以看到，回溯方法里面也用了递归，这里就应当考虑这样几个点：

​	1.递归的终点以及终点的行为：

```java
if(length==depth)res.add(new ArrayList<>(path));
return;
```

​	2.函数需要操作的变量：

```java
private dfs(List<Integer>nums,List<List<Integer>> res,Deque<Integer> path,boolean[] used,depth)
```

​	其中，既有判断跳出递归的参量：depth。也有要操作的原始数据nums和最终结果res，还有中间变量used和path。path存储一次路径，used用来判断一次过程的节点使用情况。

3.整个递归函数的撰写：

​	1.判断跳出条件。

​	2.逻辑：在每一个当下，都对所有的节点遍历，然后根据节点的使用情况，判断是否写入路径。这里的一个重要的点是，这里的used始终是和当前情况对应的，而这里的for却向前推移了，即递归里面的栈，帮我们将整个过程推进，而我们自己的回溯，又能保证穿越回上一个节点。

​	